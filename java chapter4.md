- [面向对象](#面向对象)
  - [面向过程和面向对象的区别](#面向过程和面向对象的区别)
  - [面向对象的三大特征](#面向对象的三大特征)
  - [类和对象的概念](#类和对象的概念)
  - [对象的创建和使用](#对象的创建和使用)
  - [数据类型                     默认值](#数据类型---------------------默认值)
  - [关于JVM](#关于jvm)
  - [空指针异常](#空指针异常)
  - [面向对象包括三大特征：封装、继承、多态](#面向对象包括三大特征封装继承多态)
  - [构造方法](#构造方法)
  - [对象和引用](#对象和引用)
  - [this关键字](#this关键字)
  - [例题](#例题)
  - [super关键字](#super关键字)
  - [Object类的toString方法](#object类的tostring方法)
  - [static关键字](#static关键字)
  - [实例语句块/代码块\[了解内容，使用的非常少\]](#实例语句块代码块了解内容使用的非常少)
  - [静态方法](#静态方法)
  - [继承](#继承)
  - [方法的覆盖](#方法的覆盖)
  - [多态](#多态)
  - [package](#package)
  - [import](#import)
  - [访问控制权限修改符：](#访问控制权限修改符)

# 面向对象
## 面向过程和面向对象的区别
- 面向过程：主要关注点是：实现的具体过程，因果关系[集成显卡的开发思路]
  * 优点：对于业务逻辑比较简单的程序，可以达到快速开发，前期投入成本较低。
  * 缺点：采用面向过程的方式开发很难解决非常复杂的业务逻辑，另外面向过程的方式导致软件元素之间的"耦合度"非常高，只要其中一环出问题，整个系统受到影响，导致最终的软件"扩展力"差。另外，由于没有独立体的概念，所以无法达到组件复用。
- 面向对象：主要关注点是：主要关注对象[独立体]能完成哪些功能。[独立显卡的开发思路]
  * 优点：耦合度低，扩展力强。更容易解决现实世界当中更复杂的业务逻辑。组件复用性强。
  * 缺点：前期投入成本较高，需要进行独立体的抽取，大量的系统分析与设计。
- C语言是纯面向过程的、C++半面向对象、Java纯面向对象
- 现在出现的一些新的编程语言多数都是面向对象的。人在认识现实世界的时候以面向对象的方式。
- 面向对象更符合人的思维方式。
## 面向对象的三大特征
- 封装
- 继承
- 多态
**所有面向对象的编程语言都有这三大特征**
- 采用面向对象的方式开发一个软件，生命周期当中：[整个生命周期中贯穿使用OO面向对象方式]
  * 面向对象的分析：OOA
  * 面向对象的设计：OOD
  * 面向对象的编程：OOP
## 类和对象的概念
- 什么是类？
  * 类在现实世界当中是不存在的，是一个模板，是一个概念。是人类大脑思考抽象的结果。
  * 类代表了一类事物
  * 在现实世界当中，对象A与对象B之间具有共同特征，进行抽象总结出一个模板，这个模板被称为类。
- 什么是对象
  * 对象是实际存在的个体。现实世界当中实际存在
- 描述一下整个软件开发的过程：
  * 程序员先观察世界，从现实世界当中寻找对象
  * 寻找了N多个对象之后，发现所有的对象都有共同特征
  * 程序员在大脑中形成了一个模板[类]
  * Java程序员可以通过java代码来表述一个类
  * java程序中有了类的定义
  * 然后通过类就可以创建对象
  * 有了对象之后，可以让对象直接协作起来形成一个系统
- 类--[实例化]->对象
- 对象又被称为实例/instance
- 对象--[抽象]-->类
- 重点：
  * 类描述的是对象的共同特征。
  * 共同特征例如：身高特征
  * 这个身高特征在访问的时候，必须先创建对象，通过对象去访问这个特征。因为这个特征具体在某个对象上之后，值不同。有的对象身高1.80，有的对象身高1.70
- 一个类主要描述什么信息呢？
  * 一个类主要描述的是：状态 ＋ 动作。
  * 状态信息：名字、身高、性别、年龄
  * 动作信息：吃、唱歌、跳舞、学习
  **状态--> 一个类的属性**
  **动作--> 一个类的方法**
     
     <pre>类{
        属性；//描述对象的状态信息
        方法；//描述对象的动作信息
    }</pre>
    
    **状态和动作当具体到某个对象上之后，发现最终的结果可能不一样**
    **对象和对象之间有共同特征，但是具体到对象之后有数据的差异**
- 类的定义
  * 语法结构 
<pre>
  [修饰符列表] class 类名{
    属性；
    方法；
  }
</pre>
  * 例如
    * 学生类，描述所有学生对象的共同特征
    * 学生对象有哪些状态信息：
      * 学号[int]
      * 名字[String]
      * 性别[boolean]
      * 年龄[int]
      * 住址[String]
      ...
    * 学生对象有哪些动作信息：
      * 吃饭
      * 睡觉
      * 学习
      * 娱乐
      * 唱歌
      * 跳舞
      ...
- java语言中包括两种数据类型：
  - 基本数据类型
    - byte
    - short
    - int
    - long
    - float
    - double
    - boolean
    - char  
  - 引用数据类型
    - String.class SUN提供的
    - System.class SUN提供的
    - Student.class 程序员自定义的
    - User.class 程序员自定义
    - Product.class 程序员自定义的
    - Customer.class 程序员自定义的
    ...
- java语言中所有的class都属于引用数据类型。
<pre>
//定义一个类，类名Student
//Student是一个类，代表了所有的学生对象。是一个学生模板
pubilc class Student{ //定义一个公开的类，起名Student

  //属性[描述的是对象的状态信息]
  //属性通常采用变量的方式来定义
  //在类体当中，方法体之外定义的变量被称为“成员变量”
  //成员变量没有赋值，系统赋默认值：一切向0看齐。

  //类体=属性＋方法

  //属性[存储数据采用变量的形式]
  //由于变量定义在类体当中，方法体之外，这种变量称为成员变量
  //所有学生都有学号信息，但是每一个学生的学号都是不同的
  //所以要访问这个学号必须先创建对象，通过对象去访问学号信息
  //学号信息不能直接通过“类”去访问，所以这种成员变量又被叫做：实例变量
  //对象又被称为实例，实例变量又被称为对象变量。[对象级别的变量]
  //不创建对象，这个no变量的内存空间是不存在的，只有创建了对象，这个no变量内存空间才会创建。

  //学号
  int no;

  //姓名
  String name;

  //性别
  boolean sex;

  //年龄
  int age;

  //住址
  String address;

  //方法
  //方法描述的是对象的动作信息
  //当前例子就只描述属性了，不描述方法
}
</pre>
## 对象的创建和使用
<pre>
pubilc class OOTses01{
  pubilc static void main(String[] args){
    
    //int是基本数据类型
    //i是一个变量名
    //10是一个int类型的字面值
    int i = 10;

    //通过一个类可以实例化N个对象
    //实例化对象的语法：new 类名();
    //new是java语言当中的一个运算符
    //new运算符的作用是创建对象，在JVM堆内存当中开辟新的内存空间
    //方法区内存：在类加载的时候，class字节码代码片段被加载到该内存空间当中。
    //栈内存(局部变量)：方法代码片段执行的时候，会给该方法分配内存空间，在栈内存中压栈。
    //堆内存：new的对象在堆内存中存储
    //Student是一个引用数据类型
    //s是一个变量名
    //new Student()是一个学生对象
    //s是一个局部变量[在栈内存中存储]
    //什么是对象？new运算符在堆内存中开辟的内存空间称为对象。
    //什么是引用？引用是一个变量，只不过这个变量中保存了另一个java对象的内存地址。
    //java语言当中，程序员不能直接操作堆内存，java中没有指针。不像C语言
    //java语言当中，程序员只能通过“引用”去访问堆内存当中对象内部的实例变量。
    //s保存内存地址指向堆内存的Student对象
    Student s = new Student();

    //访问实例变量的语法格式
    //  读取数据：引用.变量名
    //  修改数据：引用.变量名 = 值

  }
}
</pre>
- 成员变量没有手动赋值的话，系统赋默认值
<pre>
数据类型                     默认值
----------------------------------
byte,short,int,long          0
float,double                 0.0
boolean                      false
char                         \u0000
引用数据类型                   null 与void不同，void是返回值类型为空类型
</pre>
- 对于System.out.println(Student.no);这行代码
  - 编译报错，no这个实例变量不能直接采用“类名”的方式访问
  - 因为no是实例变量，对象级别的变量，变量存储在java对象的内部，必须先有对象
  - 通过对象才能访问no这个实例变量，不能直接通过“类名”访问
- 局部变量在栈内存中存储
- 成员变量中的实例变量在堆内存的java对象内部
<pre>
//用户类
public class User{
  //属性[以下都是成员变量之实例变量]

  //用户编号
  //int是一种基本数据类型：整数型
  //no是一个实例变量
  int no;

  //用户名
  //String是一种引用数据类型：代表字符串
  //name是一个实例变量
  //name是一个引用
  String name;

  //家庭住址
  //Address是一种引用数据类型：代表家庭住址
  //addr是一个实例变量
  //addr是一个引用
  Address addr;
}

//家庭住址类
public class Address{
  //属性[成员变量之实例变量]
  //城市
  //String是一种引用数据类型，city是一个变量名，属于实例变量
  //city是一个引用：保存内存地址的一个变量，该变量保存内存地址指向了堆内存当中的对象。
  String city;

  //街道
  String street;

  //邮编
  String zipcode;
}
</pre>

<pre>
//妻子类
public class Wife{
  //姓名
  String name;

  //妻子对象当中含有丈夫引用
  Husband h;
}
public class Husband{
  //姓名
  String name;

  //丈夫对象当中含有妻子引用
  Wife w;  
}
public class OOTest04{
  public static void main(String[] args){

    //创建一个丈夫对象
    Husband xiaozhi = new Husband();
    xiaozhi.name = "小智";

    //创建一个妻子对象
    Wife xiaoguang = new Wife();
    xiaoguang.name = "小光";

    //结婚[能通过丈夫找到妻子，通过妻子也可以找到丈夫]
    xiaozhi.w = xiaoguang;
    xiaoguang.h = xiaozhi;

    //得到以上“小智”的妻子的名字
    System.out.println(xiaozhi.name + "的妻子名字叫：" + xiaozhi.w.name);
  }
}
</pre>
## 关于JVM
1. JVM(java虚拟机)主要包括三块内存空间，分别是：栈内存、堆内存、方法区内存。
2. 堆内存和方法区内存各有1个、一个线程一个栈内存。
3. 方法调用的时候，该方法所需要的内存空间在栈内存中分配，称为压栈。方法执行结束之后，该方法所属的内存空间释放，称为弹栈。
4. 栈中主要存储的是方法体当中的局部变量。
5. 方法的代码片段以及整个类的代码片段都被存储到方法区内存当中，在类加载的时候这些代码片段会载入。
6. 在程序执行过程中使用new运算符创建的java对象，存储在堆内存当中。对象内部有实例变量，所以实例变量存储在堆内存当中。
7. 变量分类：
   - 局部变量[方法体中声明]
   - 成员变量[方法体外声明]
     - 实例变量[前边修饰符没有static]
     - 静态变量[前边修饰符中有static]
8. 静态变量存储在方法区内存当中。
9. 三块内存当中变化最频繁的是栈内存，最先有数据的是方法区内存，垃圾回收期主要针对的是堆内存。
10. 垃圾回收器[自动垃圾回收机制、GC机制]什么时候会考虑将某个java对象的内存回收呢？
- 当堆内存当中的java对象成为垃圾数据的时候，会被垃圾回收器回收。
- 什么时候堆内存中的java对象会变成垃圾呢？
  - 没有更多的引用指向它的时候，这个对象无法被访问。因为访问对象只能通过引用的方式访问。
## 空指针异常
<pre>
public class OOTest05{
  public static void main(String[] args){

    Customer c = new Customer();
    System.out.println(c.id); //0

    c = null;

    //以下程序编译可以通过，因为符合语法
    //运行出现空指针异常。
    //空引用访问“实例”相关的数据一定会出现空指针异常
    //java.lang.NullPointerException
    System.out.println(c.id);

    //“实例”相关的数据表示：这个数据访问的时候必须有对象的参与。这种数据就是实例相关的数据。
  }
</pre>
## 面向对象包括三大特征：封装、继承、多态
1. 封装的好处
   - 封装之后，对于那个事物来说，看不到这个事物比较复杂的那一面，只能看到该事物简单的那一面。复杂性封装，对外提供简单的操作入口。照相机就是一个很好的封装的案例，照相机的实现原理非常复杂，但是对于使用照相机的人来说，操作起来是非常方便的是非常便捷的。还有像电视机也是封装的，电视机内部实现非常复杂，但是对于使用者来说不需要关心内部的实现原理，只需要会操作遥控器就行。
   - 封装之后才会形成真正的“对象”，真正的“独立体”
   - 封装就意味着以后的程序可以重复使用。并且这个事物应该适应性比较强，在任何场合都可以使用。
   - 封装之后，对于事物本身，提高了安全性。[安全级别高]
2. 封装的步骤：
   - 所有属性私有化，使用private关键字进行修饰，private表示私有的，修饰的所有数据只能在本类中访问。
   - 对外提供简单的操作入口，也就是说以后外部程序要想访问age属性，必须通过这些简单的入口进行访问：
     - 对外提供两个公开的方法，分别是set方法和get方法
     - 想修改age属性，调用set方法
     - 想读取age属性，调用get方法
   - set方法的命名规范：
     - public void set + 属性名首字母大写(形参){}
     - 比如：
<pre>
public void setAge(int a){
  age = a;
}
</pre>
   - get方法的命名规范：
     - public 返回值类型 get + 属性名首字母大写(形参){}
<pre>
public void getAge(){
  return age;
}
</pre>
   - 回想一下，一个属性通常访问的时候包括几种访问形式？
     - 第一种方式：想读取这个属性的值，读取get
     - 第二种方式：想修改这个属性的值，修改set
   - setter and getter方法没有static关键字
   - 有static关键字修饰的方法怎么调用：类名.方法名(实参);
   - 没有static关键字修饰的方法怎么调用：引用.方法名(实参);
## 构造方法
1. 构造方法又被称为构造函数/构造器/Constructor
2. 构造方法语法结构：
<pre>
[修饰符列表] 构造方法名(形式参数列表){
  方法体;        
}
</pre>
3. 回顾普通方法的语法结构
<pre>
[修饰符列表] 返回值类型 方法名(形式参数列表){
  方法体;
}
</pre>
4. 对于构造方法来说，“返回值类型”不需要指定，并且也不能写void，只要写上void，那么这个方法就成为普通方法了。
5. 对于构造方法来说，构造方法的方法名必须和类名保持一致。
6. 构造方法的作用？
- 构造方法存在的意义是，通过构造方法的调用，可以创建对象。
7. 构造方法应该怎么调用？
- 普通方法是这样调用的：
  - 方法修饰符中有static的时候：类名.方法名(实参列表)
  - 方法修饰符中没有static的时候：引用.方法名(实参列表)
- new 构造方法名(实参列表)
8. 构造方法调用执行之后，有返回值吗？
- 每一个构造方法实际上执行结束之后都有返回值，但是这个“return 值;”这样的语句不需要写。构造方法结束的时候java程序自动返回值，并且返回值类型是构造方法所在类的类型。由于构造方法的返回值类型就是类本身，所以返回值类型不需要编写。
**注释和取消注释：ctrl + /，多行注释：ctrl + shift + /**
9.  当一个类中没有定义任何构造方法的话，系统默认给该类提供一个无参数的构造方法，这个构造方法被称为缺省构造器。
10.  当一个类显示的将构造方法定义出来了，那么系统则不再默认为这个类提供缺省构造器。建议开发中手动的为当前类提供无参数构造方法。因为无参数构造方法太常用了。
11.  构造方法支持重载机制。在一个类当中编写多个构造方法，这多个构造方法显然已经构成方法重载机制。
12.  只要构造函数调用就会创建对象，并且一定是在“堆内存”中开辟内存空间。
**怎么查看访问的是哪个属性，查看访问的是哪个方法：按住ctrl，鼠标移动到查看的元素上，出现下划线的时候开始单击。**
13. 构造方法不仅可以创建对象，还能给实例变量赋值
- 成员变量之实例变量，属于对象级别的变量，这种变量必须先有对象才能有实例变量。实例变量没有手动赋值的时候，系统默认赋值，那么这个系统默认赋值是在什么时候完成的呢？
  - 是在类加载的时候吗？
    - 不是，因为类加载的时候只加载了代码片段，还没来得及创建对象。所以此时实例变量并没有初始化。
  - 实际上，实例变量的内存空间是在构造方法执行过程当中开辟的。完成初始化的。系统在默认赋值的时候，也是在构造方法执行过程当中完成的赋值。
## 对象和引用
- 对象和引用的概念
  - 对象：目前在使用new运算符在堆内存中开辟的内存空间称为对象。
  - 引用：是一个变量，不一定是局部变量，还可能是成员变量。引用保存了内存地址，指向了堆内存当中的对象。
  - 所有访问实例相关的数据，都需要通过“引用.”的方式访问，因为只有通过引用才能找到对象。
  - 只有一个空的引用，访问对象的实例相关的数据会出现空指针异常。
<pre>  
class Student{
  Computer com; //com是一个引用[实例变量]

  public static void doSome(){
    Computer cc；//cc是一个引用[局部变量]
  }
}
</pre>
- 参数的传递
  - 参数传递实际上传递的是变量中保存的具体值
  - 方法调用的时候，涉及到参数传递的问题，传递的时候，java只遵循一种语法机制，就是将变量中保存的“值”传递过去了，只不过有的时候这个值是一个字面值10，有的时候这个值是另一个java对象的内存地址0x1234
<pre>
int i = 10;
add(i);等同于add(10);
</pre>
<pre>
User u = new User(20);
//User u = 0x1234;
//传递u给add方法的时候，实际上传递的是u变量中保存的值，只不过这个值是一个java对象的内存地址。
add(u);//等同于add(0x1234);
</pre>
## this关键字
1. this是一个关键字，翻译为：这个
2. this是一个引用，this是一个变量，this变量中保存了内存地址指向了自身，this存储在JVM堆内存java对象内部。
3. 创建100个java对象，每一个对象都有this，也就说有100个不同的this
4. this可以出现在“实例方法”当中，this指向当前正在执行这个动作的对象(this代表当前对象)
5. this在多数情况下都是可以省略不写的
6. this不能使用在带有static的方法中
7. 在带有static的方法当中不能“直接”访问实例变量和实例方法。因为实例变量和实例方法都需要对象的存在。而static的方法当中是没有this的。也就是说当前对象是不存在的。自然也是无法访问当前对象的实例变量和实例方法。
- 没有static关键字的方法被称为“实例方法”，实例方法怎么访问？“引用”
- 没有static关键字的方法被称为“实例变量”
**当一个行为/作动执行的过程当中是需要对象参与的，那么这个方法一定要定义为“实例方法”，不要带static关键字**
**this.什么时候不能省略：用来区分局部变量和实例变量的时候，this.不能省略**
- this可以用在哪里：
  - 可以使用在实例方法当中，代表当前对象[语法格式：this.]
  - 可以使用在构造方法当中，通过当前的构造方法调用其他的构造方法[语法格式：this(实参);]
**this()这种语法只能出现在构造函数第一行。**
- 带有static的方法，其实既可以采用类名的方式访问，也可以采用引用的方式访问，但是即使采用引用的方式去访问，实际上执行的时候和引用指向的对象无关，所以带有static的方法还是建议使用“类名.”的方式访问。
## 例题
<pre>
public class Test(){

  //没有static的变量
  int i = 10;

  //带有static的方法
  public static void doSome(){
    System.out.println("do some!");
  }

  //没有static的方法
  public void doOther(){
    System.out.println("do other!");
  }

  //带有static的方法
  public static void method1(){

    //调用doSome
    //完整方式的调用
    Test.doSome();
    //省略方式的调用
    doSome();

    //调用doOther
    //完整方式的调用
    Test tt = new test();
    tt.doOther();
    //省略方式的调用
    无

    //访问i
    //完整方式的调用
    System.out.println(tt.i);
    //省略方式的调用
    无

  }
    //没有static的方法
    public void method2(){

      //调用doSome
      完整方式的调用
      Test.doSome();
      省略方式的调用
      doSome();

      //调用doOther
      //完整方式的调用
      this.doOther();
      //省略方式的调用
      doOther();

      //访问i
      //完整方式的调用
      System.out.println(this.i);
      //省略方式的调用
      System.out.println(i);
    }
    //主方法
    public static void main(String[] args){

      //要求在这里编写程序调用method1
      //使用完整方式调用
      Test.method1();
      //使用省略方式调用
      method1();

      //要求在这里编写程序调用method2
      //使用完整方式调用
      Test t = new Test();
      t.method2();
      //使用省略方式调用
      无

    }
}
</pre>
## super关键字
1. super是一个关键字，全部小写。
2. super和this对比着学习。
- this
  - this能出现在实例方法和构造方法中。
  - this的语法是："this."、"this()"
  - this不能使用在静态方法中。
  - this.大部分情况下是可以省略的。
  - this.什么时候不能省略呢？在区分局部变量和实例变量的时候不能省略。
  - this() 只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中的其他的构造方法，目的是：代码复用
<pre>
public void setName(String name){
  this.name = name;
}
</pre>

- super:
  - super能出现在实例方法和构造方法中。
  - super的语法是："super."、"super()"
  - super不能使用在静态方法中。
  - super.大部分情况下是可以省略的。
  - super.什么时候不能省略呢？
  - super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中的其他的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。
3. super()
- 表示通过子类的构造方法调用父类的构造方法。
- 模拟现实世界中的这种场景：要想有儿子，需要先有父亲。
4. 重要的结论：
- 当一个构造方法第一行：
  - 既没有this()又没有super()的话，默认会有一个super();
  - 表示通过当前子类的构造方法调用父类的无参数构造方法。
  - 所以必须保证父类的无参数构造方法是存在的。
**this()和super() 不能共存，它们都是只能出现在构造方法第一行。**
5. 无论怎么用折腾，父类的构造方法是一定会执行的。(百分百的)
6. 在java语言中不管是new什么对象，最后老祖宗的Object类的无参数构造方法一定会执行。(Object类的无参数构造方法是处于“栈顶部”)
7. 栈顶的特点:
- 最后调用，但是最先执行结束。后进先出的原则。

**以后写代码的时候，一个类的无参数构造方法还是建议手动的写出来。如果无参数构造方法丢失的话，可能会影响到“子类对象的构建”。**

7. 在构造方法执行过程中一连串调用了父类的构造方法，父类的构造方法又继续向下调用它的父类的构造方法，但是实际上对象只创建了一个。
8. super(实参)到底是干啥的？
- super(实参)的作用是：初始化当前对象的父类型特征。并不是创建新对象。实际上对象只创建了1个。
9. super关键字代表什么？
- super关键字代表的就是"当前对象"的那部分父类型特征。
10. super和this都不能出现在静态方法中。this表示当前对象，super表示的是当前对象的父类型特征(super是this指向的那个对象中的一块空间)
11. "this."和"super."大部分情况下都是可以省略的。
- this.什么时候不能省略？
  <pre>
  public void setName(String name){
    this.name = name;
  }
  </pre>
- super.什么时候不能省略？
  - 父中有，子中又有，如果想在子中访问"父的特征"，super.不能省略。
12. super不是引用。super也不保存内存地址，super也不指向任何对象。super只是代表当前对象内部的那一块父类型的特征
13. 在父和子中有同名的属性，或者说有相同的方法，如果此时想在子类中访问父中的数据，必须使用"super."
加以区分。
- super.属性名        [访问父类的属性]
- super.方法名(实参)    [访问父类的方法]    
- super(实参)         [调用父类的构造方法]
## Object类的toString方法
当直接输出一个"引用"的时候，println()方法会先自动调用"引用.toString()"，然后输出toString()方法的执行结果。这个执行结果可以形式为"类名+@+地址"，地址可以"等同"看作对象在堆内存当中的内存地址。实际上内存地址经过"哈希算法"得出的十六进制结果。
## static关键字
1. static英语单词翻译为静态的
2. static修饰的方法是静态方法
3. static修饰的变量是静态变量，静态变量在类加载的时候初始化，不需要创建对象，内存就开辟了。静态变量存储在方法区内存当中。
4. 所有static修饰的元素都称为静态的，都可以使用“类名.”的方式访问，当然也可以用“引用.”的方式访问[但不建议]
5. static修饰的所有元素都是类级别的特征，和具体的对象无关。
- 什么时候成员变量声明为实例变量呢？
  - 所有对象都有这个属性，但是这个属性的值会随着对象的变化而变化[不同对象的这个属性具体的值不同]
- 什么时候成员变量声明为静态变量呢？
  - 所有对象都有这个属性，并且所有对象的这个属性的值是一样的，建议定义为静态变量，节省内存的空间。
1. 可以使用static关键字来定义“静态代码块”。
<pre>
语法格式：
  static{
    java语句;
  }
</pre>
1. 静态代码在类加载时执行，并且只执行一次。
2. 静态代码在一个类中可以编写多个，并且遵循自上而下的顺序依次执行。
3. 静态代码块的作用是什么？怎么用？用在哪儿？什么时候用？
- 和具体的需求有关，例如项目中要求在类加载的时刻/时机执行代码完成日志的记录。那么这段记录日志的代码就可以编写到静态代码当中，完成日志记录。
- 静态代码块是java为程序员准备的一个特殊时刻，这个特殊的时刻被称为类加载时刻。若希望在此刻执行一段特殊的程序，这段程序可以直接放到静态代码块当中。
1. 通常在静态代码块当中完成预备工作，先完成数据的准备工具，例如：初始化连接池，解析XML配置文件
## 实例语句块/代码块[了解内容，使用的非常少]
1. 实例代码块可以编写多个，也是遵循自上而下的顺序依次执行
2. 实例代码块在构造方法执行之前执行，构造方法执行一次，实例代码块对应执行一次。
3. 实例代码块也是java语言为程序员准备一个特殊的时机，这个特殊时机被称为：对象初始化时机。
## 静态方法
- 方法什么时候定义为静态的？
  - 方法描述的是动作，当所有的对象执行这个动作的时候，最终产生影响是一样的，那么这个动作已经不再属于某一个对象动作了，可以将这个动作提升为类级别的动作，模板级别的动作。
- 静态方法中无法直接访问实例变量和实例方法
- 大多数方法都定义为实例方法，一般一个行为或者一个动作在发生的时候，都需要对象的参与。但是也有例外，例如：大多数“工具类”中的方法都是静态方法，因为工具类就是方便编程，为了方便方法的调用，自然不需要new对象是最好的。
<pre>
class 类{
  静态代码块;
  实例代码块;

  静态变量
  实例变量

  构造方法

  静态方法
  实例方法
}
</pre>
## 继承
1. 继承是面向对象三大特征之一，三大特征分别是：封装、继承、多态
2. 继承“基本”的作用是：代码复用。但是继承最“重要”的作用是：有了继承才有了以后“方法的覆盖”和“多态机制”。
3. 继承语法格式：
[修饰符列表] class 类名 extends 父类名{
  类体 = 属性 + 方法
}
4. java语言当中的继承只支持单继承，一个类不能同时继承很多类，只能继承一个类。在C++中支持多继承。
5. 关于继承中的一些术语：
  B类继承A类，其中：
    A类称为：父类、基类、超类、superclass
    B类称为：子类、派生类、subclass
6. 在java语言当中子类继承父类都继承哪些数据呢？
- 私有的不支持继承
- 构造方法不支持继承
- 其他数据都可以被继承
7. 虽然java语言当中只支持单继承，但是一个类也可以间接继承其他类，例如：
  C extends B{
  }
  B extends A{
  }
  A extends T{    
  }
  C直接继承B类，但是C类间接继承T、A类。
8. java语言中假设一个类没有显示的继承任何类，该类默认继承javaSE库当中提供的java.lang.Object类。java语言中任何一个类中都有Object类的特征。
## 方法的覆盖
1. 方法覆盖又被称为方法重写，英语单词：override[官方的]/overwrite
2. 什么时候使用方法重写？
- 当父类中的方法已经无法满足当前子类的业务需求，子类有必要将父类中继承过来的方法进行重新编写，这个重新编写的过程称为方法重写/方法覆盖。
3. 什么条件满足之后方法会发生重写呢？[代码满足什么条件之后，就构成方法的覆盖呢？]
- 方法重写发生在具有继承关系的父子类之间
- 方法重写的时候，返回值类型相同，方法名相同，形参列表相同
- 方法重写的时候：访问权限不能更低，可以更高。
- 方法重写的时候：抛出异常不能更多，可以更少。
4. 注意：
- 私有方法不能继承，所以不能覆盖。
- 构造方法不能继承，所以不能覆盖。
- 静态方法不存在覆盖。
- 覆盖只针对方法，不谈属性。
## 多态
1. 关于多态中涉及到的几个概念：
- 向上转型(upcasting)
  - 子类型 --> 父类型
  - 又被称为：自动类型转换。
- 向下转型(downcasting)
  - 父类型 --> 子类型
  - 又被称为：强制类型转换。[需要加强制类型转换符]
**无论是向上转型还是向下转型，两种类型之间必须要有继承关系。没有继承关系，程序是无法编译通过的。**
<pre>
//动物类
public class Animal{
  
  public void move(){
    System.out.println("动物在移动");
  }
}
</pre>
<pre>
//猫类
public class Cat extends Animal{

  //重写父类中继承过来的方法
  public void move(){
    System.out.println("猫在走猫步！");
  }

  //不是从父类中继承过来的方法
  //这个方法是子类对象特有的行为[不是说所有的动物都能抓老鼠！]
  public void catchMouse(){
    System.out.println("猫抓老鼠！");
  }
}
</pre>
<pre>
public class Bird extends Animal{
  
  //重写从父类中继承过来的方法
  public void move(){
    System.out.println("鸟儿在飞翔！");
  }

  //子类对象特有的行为/动作
  public void fly(){
    System.out.println("Bird fly!");
  }
}
</pre>
<pre>
public class Test{
  public static void main(String[] args){
    
    //以前编写的程序

    Animal a1 = new Animal();
    a1.move();

    Cat c1 = new Cat();
    c1.move();
    c1.catchMouse();

    Bird b1 = new Bird();
    b1.move();

    // 使用多态语法机制

    // 1.Animal和Cat之间存在继承关系，Animal是父类，Cat是子类
    // 2.Cat is an Animal[合理]
    // 3.new Cat()创建的对象的类型是Cat，a2这个引用的数据类型是Animal，可见它们进行了类型转换。子类型转换成父类型，称为向上转型/upcasting，或者称为自动类型转换。
    // 4.java中允许这种语法：父类型引用指向子类型对象。
    Animal a2 = new Cat();

    // 1.java程序永远都分为编译阶段和运行阶段。
    // 2.先分析编译阶段，再分析运行阶段，编译无法通过，根本是无法运行的。
    // 3.编译阶段编译器检查a2这个引用的数据类型为Animal，由于Animal，class字节码当中有move()方法，所以编译通过了。这个过程我们称为静态绑定，编译阶段绑定。只有静态绑定成功之后才有后续的运行。
    // 4.在程序运行阶段，JVM堆内存当中真实创建的对象是Cat对象，那么以下程序在运行阶段一定会调用Cat对象的move()方法，此时发生了程序的动态绑定，运行阶段绑定。
    // 5.无论是Cat类有没有重写move方法，运行阶段一定调用的是Cat对象的move方法，因为底层真实对象就是Cat对象。
    // 6.父类型引用指向子类型对象这种机制导致程序存在编译阶段绑定和运行阶段绑定两种不同的形态/状态，这种机制可以成为一种多态语法机制。
    a2.move();

    //分析以下程序为什么不能调用？
    // 因为编译阶段编译器检查到a2的类型是Animal类型，从Animal.class字节码文件当中查找catchMouse()方法，最终没有找到该方法，导致静态绑定失败，没有绑定成功，也就是说编译失败了。别谈运行了。
    a2.catchMouse();

    // 需求：
    // 假设想让以上的对象执行catchMouse()方法，怎么办？
      // a2是无法直接调用的，因为a2的类型Animal，Animal中没有catchMouse()方法。
      // 我们可以将a2强制类型转换成Cat类型。
      // a2的类型是Animal(父类)，转换成Cat类型(子类)，被称为向下转型/downcasting/强制类型转换。
    // 向下转型也需要两种类型之间必须有继承关系。不然编译报错。强制类型转换需要加强制类型转换符。
    // 什么时候需要使用向下转型呢？
      // 当调用的方法是子类型中特有的，在父类型当中不存在，必须进行向下转型。
    Cat c2 = (Cat)a2;
    c2.catchMouse(); //猫抓老鼠！

    //父类型引用指向子类型对象[多态]
    Animal a3 = new Bird();

    // 1.以下程序编译是没有问题，因为编译器检查到a3的数据类型是Animal。Animal和Cat之间存在继承关系，并且Animal是父类型，Cat是子类型，父类型转换成子类型叫做向下转型，语法合格。

    // 2.程序虽然编译通过了，但是程序在运行阶段会出现异常，因为JVM堆内存当中真实存在的对象是Bird类型，Bird对象无法转换成Cat对象，因为两种类型之间不存在任何继承关系，此时出现了著名的异常：
      // java.lang.ClassCastException
      // 类型转换异常，这种异常总是在“向下转型”的时候会发生
    Cat c3 = (Cat)a3;

    // 1.以上异常只有在强制类型转换的时候会发生，也就是说“向下转型”存在隐患(编译通过了，但是运行出错了！)
    // 2.向上转型只要编译通过，运行一定不会出问题：Animal a = new Cat();
    // 3.向下转型编译通过，运行可能错误：Animal a3 = new Bird();Cat c3 = (Cat)a3;
    // 4.怎么避免向下转型出现的ClassCastException呢？
          // 使用instanceof运算符可以避免出现以上的异常。
  }
}
</pre>
2. 关于java语言当中的多态语法机制：
- Animal、Cat、Bird三个类之间的关系：
  - Cat继承Animal
  - Bird继承Animal
  - Cat和Bird之间没有任何继承关系
- 面向对象三大特征：封装、继承、多态
3. instanceof运算符怎么用？
- 语法格式：
  - 引用 instanceof 数据类型名
- 以上运算符的执行结果类型是布尔类型，结果可能是true/false
- 关于运算结果true/false:
  - 假设：(a instanceof Animal)
  - true表示：
    - a这个引用指向的对象是一个Animal类型。
  - false表示：
    - a这个引用指向的对象不是一个Animal类型。
- 在进行强制类型转换之前，建议采用instanceof运算符进行判断，避免ClassCastException异常的发生。
<pre>
//父类型引用指向子类型对象
//向上转型
Animal a1 = new Cat();

Animal a2 = new Bird();

//向下转型[只有当访问子类对象当中特有的方法]
if(a1 instanceof Cat){
  Cat c1 = (Cat)a1;

  //调用子类对象中特有的方法
  c1.catchMouse();
}
if(a2 instanceof Bird){
  Bird b1 = (Bird)a2;

  //调用子类对象中特有的方法
  b1.fly();
}
</pre>
4. 面向对象编程的核心：
- 定义好类，然后将类实例化为对象，给一个环境驱使一下，让各个对象之间协作起来形成一个系统。
5. 多态的作用
- 降低程序的耦合度，提高程序的扩展力
- 能使用多态尽量使用多态
- 父类型引用指向子类型对象。

**面向抽象编程，尽量不要面向具体编程**

## package
  关于java语言当中的包机制：
1. 包又称为package，java中引入package这种语法机制主要是为了方便程序的管理。不同功能的类被分门别类放到不同的软件包当中，查找比较方便，管理比较方便，易维护。
2. 怎么定义package呢？
- 在java源程序的第一行上编写package语句。
- package只能编写一个语句。
- 语法结构：
  - package 包名;
3. 包名的命名规范：
- 公司域名倒序 + 项目名 + 模块名 + 功能名;
- 采用这种方式重名的几率较低。因为公司域名具有全球唯一性。
- 例如：com.bjpowernode.oa.user.service;  org.apache.tomcat.core;
4. 包名要求全部小写，包名也是标识符，必须遵守标识符的命名规则。
5. 一个包对应一个目录。
6. 使用了package机制之后，应该怎么编译？怎么运行呢？
- 使用了package机制之后，类名不再是Test01了，类名是:com.bjpowernode.javase.day11.Test01
- 编译：javac java源文件路径(在硬盘上生成一个class文件：Test01.class)
- 手动方式创建目录，将Test01.class字节码文件放到指定的目录下
- 运行：java com.bjpowernode.javase.day11.Test01
- 另一种方式(编译 + 运行)：
  - 编译：
    - javac -d 编译之后存放路径 java源文件的路径
  - 例如：将F:\Hello.java文件编译之后放到C:\目录下
    - javac -d C:\ F:\Hello.java
  - javac -d .*java
    - 将当前路径中*.java编译之后存放到当前目录下。
  - 运行：JVM的类加载器ClassLoader默认从当前路径下加载。
    - 保证DOS命令窗口的路径先切换到com所在的路径，执行：
      - java com.bjpowernode.javase.day11.Test01
<pre>
package com.bjpowernode.javase.day11; //4个目录[目录之间使用.隔开]
public clas Test01{
  public static void main(String[] args){
    System.out.println("Test01's main method execute!")
  }
}
</pre>
## import
1. import语句用来完成导入其他类，同一个包下的类不需要导入，不在同一个包下需要手动导入。
2. import语法格式：
- import 类名;
- import 包名.*;
3. import语句需要编写到package语句之下，class语句之上
4. java.lang.*;不需要手动引入，系统自动引入。
5. lang：language语言包，是java语言的核心类，不需要手动引入。所以可以String s = "abc";
6. 什么时候需要import？
- 不是java.lang包下，并且不再同一个包下的时候，需要使用improt进行引入。
## 访问控制权限修改符：
1. 访问控制权限修饰符来控制元素的访问范围
2. 访问控制权限修饰符包括：
- public      表示公开的，在任何位置都可以访问
- protected   同包，子类
- 缺省         同包
- private     表示私有的，只能在本类中访问
3. 访问控制权限修饰符可以修饰类、变量、方法...
4. 当某个数据只希望子类使用，使用protected进行修饰。
5. 修饰符的范围：private < 缺省 < protected < public
6. 类只能采用public和缺省的修饰符进行修饰。[内部类除外]