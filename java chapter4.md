# 面向对象
## 面向过程和面向对象的区别
- 面向过程：主要关注点是：实现的具体过程，因果关系[集成显卡的开发思路]
  * 优点：对于业务逻辑比较简单的程序，可以达到快速开发，前期投入成本较低。
  * 缺点：采用面向过程的方式开发很难解决非常复杂的业务逻辑，另外面向过程的方式导致软件元素之间的"耦合度"非常高，只要其中一环出问题，整个系统受到影响，导致最终的软件"扩展力"差。另外，由于没有独立体的概念，所以无法达到组件复用。
- 面向对象：主要关注点是：主要关注对象[独立体]能完成哪些功能。[独立显卡的开发思路]
  * 优点：耦合度低，扩展力强。更容易解决现实世界当中更复杂的业务逻辑。组件复用性强。
  * 缺点：前期投入成本较高，需要进行独立体的抽取，大量的系统分析与设计。
- C语言是纯面向过程的、C++半面向对象、Java纯面向对象
- 现在出现的一些新的编程语言多数都是面向对象的。人在认识现实世界的时候以面向对象的方式。
- 面向对象更符合人的思维方式。
## 面向对象的三大特征
- 封装
- 继承
- 多态
**所有面向对象的编程语言都有这三大特征**
- 采用面向对象的方式开发一个软件，生命周期当中：[整个生命周期中贯穿使用OO面向对象方式]
  * 面向对象的分析：OOA
  * 面向对象的设计：OOD
  * 面向对象的编程：OOP
## 类和对象的概念
- 什么是类？
  * 类在现实世界当中是不存在的，是一个模板，是一个概念。是人类大脑思考抽象的结果。
  * 类代表了一类事物
  * 在现实世界当中，对象A与对象B之间具有共同特征，进行抽象总结出一个模板，这个模板被称为类。
- 什么是对象
  * 对象是实际存在的个体。现实世界当中实际存在
- 描述一下整个软件开发的过程：
  * 程序员先观察世界，从现实世界当中寻找对象
  * 寻找了N多个对象之后，发现所有的对象都有共同特征
  * 程序员在大脑中形成了一个模板[类]
  * Java程序员可以通过java代码来表述一个类
  * java程序中有了类的定义
  * 然后通过类就可以创建对象
  * 有了对象之后，可以让对象直接协作起来形成一个系统
- 类--[实例化]->对象
- 对象又被称为实例/instance
- 对象--[抽象]-->类
- 重点：
  * 类描述的是对象的共同特征。
  * 共同特征例如：身高特征
  * 这个身高特征在访问的时候，必须先创建对象，通过对象去访问这个特征。因为这个特征具体在某个对象上之后，值不同。有的对象身高1.80，有的对象身高1.70
- 一个类主要描述什么信息呢？
  * 一个类主要描述的是：状态 ＋ 动作。
  * 状态信息：名字、身高、性别、年龄
  * 动作信息：吃、唱歌、跳舞、学习
  **状态--> 一个类的属性**
  **动作--> 一个类的方法**
     
     <pre>类{
        属性；//描述对象的状态信息
        方法；//描述对象的动作信息
    }</pre>
    
    **状态和动作当具体到某个对象上之后，发现最终的结果可能不一样**
    **对象和对象之间有共同特征，但是具体到对象之后有数据的差异**
- 类的定义
  * 语法结构 
<pre>
  [修饰符列表] class 类名{
    属性；
    方法；
  }
</pre>
  * 例如
    * 学生类，描述所有学生对象的共同特征
    * 学生对象有哪些状态信息：
      * 学号[int]
      * 名字[String]
      * 性别[boolean]
      * 年龄[int]
      * 住址[String]
      ...
    * 学生对象有哪些动作信息：
      * 吃饭
      * 睡觉
      * 学习
      * 娱乐
      * 唱歌
      * 跳舞
      ...
- java语言中包括两种数据类型：
  - 基本数据类型
    - byte
    - short
    - int
    - long
    - float
    - double
    - boolean
    - char  
  - 引用数据类型
    - String.class SUN提供的
    - System.class SUN提供的
    - Student.class 程序员自定义的
    - User.class 程序员自定义
    - Product.class 程序员自定义的
    - Customer.class 程序员自定义的
    ...
- java语言中所有的class都属于引用数据类型。
<pre>
//定义一个类，类名Student
//Student是一个类，代表了所有的学生对象。是一个学生模板
pubilc class Student{ //定义一个公开的类，起名Student

  //属性[描述的是对象的状态信息]
  //属性通常采用变量的方式来定义
  //在类体当中，方法体之外定义的变量被称为“成员变量”
  //成员变量没有赋值，系统赋默认值：一切向0看齐。

  //类体=属性＋方法

  //属性[存储数据采用变量的形式]
  //由于变量定义在类体当中，方法体之外，这种变量称为成员变量
  //所有学生都有学号信息，但是每一个学生的学号都是不同的
  //所以要访问这个学号必须先创建对象，通过对象去访问学号信息
  //学号信息不能直接通过“类”去访问，所以这种成员变量又被叫做：实例变量
  //对象又被称为实例，实例变量又被称为对象变量。[对象级别的变量]
  //不创建对象，这个no变量的内存空间是不存在的，只有创建了对象，这个no变量内存空间才会创建。

  //学号
  int no;

  //姓名
  String name;

  //性别
  boolean sex;

  //年龄
  int age;

  //住址
  String address;

  //方法
  //方法描述的是对象的动作信息
  //当前例子就只描述属性了，不描述方法
}
</pre>
## 对象的创建和使用
<pre>
pubilc class OOTses01{
  pubilc static void main(String[] args){
    
    //int是基本数据类型
    //i是一个变量名
    //10是一个int类型的字面值
    int i = 10;

    //通过一个类可以实例化N个对象
    //实例化对象的语法：new 类名();
    //new是java语言当中的一个运算符
    //new运算符的作用是创建对象，在JVM堆内存当中开辟新的内存空间
    //方法区内存：在类加载的时候，class字节码代码片段被加载到该内存空间当中。
    //栈内存(局部变量)：方法代码片段执行的时候，会给该方法分配内存空间，在栈内存中压栈。
    //堆内存：new的对象在堆内存中存储
    //Student是一个引用数据类型
    //s是一个变量名
    //new Student()是一个学生对象
    //s是一个局部变量[在栈内存中存储]
    //什么是对象？new运算符在堆内存中开辟的内存空间称为对象。
    //什么是引用？引用是一个变量，只不过这个变量中保存了另一个java对象的内存地址。
    //java语言当中，程序员不能直接操作堆内存，java中没有指针。不像C语言
    //java语言当中，程序员只能通过“引用”去访问堆内存当中对象内部的实例变量。
    //s保存内存地址指向堆内存的Student对象
    Student s = new Student();

    //访问实例变量的语法格式
    //  读取数据：引用.变量名
    //  修改数据：引用.变量名 = 值

  }
}
</pre>
- 成员变量没有手动赋值的话，系统赋默认值
<pre>
数据类型                     默认值
----------------------------------
byte,short,int,long          0
float,double                 0.0
boolean                      false
char                         \u0000
引用数据类型                   null 与void不同，void是返回值类型为空类型
</pre>
- 对于System.out.println(Student.no);这行代码
  - 编译报错，no这个实例变量不能直接采用“类名”的方式访问
  - 因为no是实例变量，对象级别的变量，变量存储在java对象的内部，必须先有对象
  - 通过对象才能访问no这个实例变量，不能直接通过“类名”访问
- 局部变量在栈内存中存储
- 成员变量中的实例变量在堆内存的java对象内部
<pre>
//用户类
public class User{
  //属性[以下都是成员变量之实例变量]

  //用户编号
  //int是一种基本数据类型：整数型
  //no是一个实例变量
  int no;

  //用户名
  //String是一种引用数据类型：代表字符串
  //name是一个实例变量
  //name是一个引用
  String name;

  //家庭住址
  //Address是一种引用数据类型：代表家庭住址
  //addr是一个实例变量
  //addr是一个引用
  Address addr;
}

//家庭住址类
public class Address{
  //属性[成员变量之实例变量]
  //城市
  //String是一种引用数据类型，city是一个变量名，属于实例变量
  //city是一个引用：保存内存地址的一个变量，该变量保存内存地址指向了堆内存当中的对象。
  String city;

  //街道
  String street;

  //邮编
  String zipcode;
}
</pre>

<pre>
//妻子类
public class Wife{
  //姓名
  String name;

  //妻子对象当中含有丈夫引用
  Husband h;
}
public class Husband{
  //姓名
  String name;

  //丈夫对象当中含有妻子引用
  Wife w;  
}
public class OOTest04{
  public static void main(String[] args){

    //创建一个丈夫对象
    Husband xiaozhi = new Husband();
    xiaozhi.name = "小智";

    //创建一个妻子对象
    Wife xiaoguang = new Wife();
    xiaoguang.name = "小光";

    //结婚[能通过丈夫找到妻子，通过妻子也可以找到丈夫]
    xiaozhi.w = xiaoguang;
    xiaoguang.h = xiaozhi;

    //得到以上“小智”的妻子的名字
    System.out.println(xiaozhi.name + "的妻子名字叫：" + xiaozhi.w.name);
  }
}
</pre>
## 关于JVM
1. JVM(java虚拟机)主要包括三块内存空间，分别是：栈内存、堆内存、方法区内存。
2. 堆内存和方法区内存各有1个、一个线程一个栈内存。
3. 方法调用的时候，该方法所需要的内存空间在栈内存中分配，称为压栈。方法执行结束之后，该方法所属的内存空间释放，称为弹栈。
4. 栈中主要存储的是方法体当中的局部变量。
5. 方法的代码片段以及整个类的代码片段都被存储到方法区内存当中，在类加载的时候这些代码片段会载入。
6. 在程序执行过程中使用new运算符创建的java对象，存储在堆内存当中。对象内部有实例变量，所以实例变量存储在堆内存当中。
7. 变量分类：
   - 局部变量[方法体中声明]
   - 成员变量[方法体外声明]
     - 实例变量[前边修饰符没有static]
     - 静态变量[前边修饰符中有static]
8. 静态变量存储在方法区内存当中。
9. 三块内存当中变化最频繁的是栈内存，最先有数据的是方法区内存，垃圾回收期主要针对的是堆内存。
10. 垃圾回收器[自动垃圾回收机制、GC机制]什么时候会考虑将某个java对象的内存回收呢？
- 当堆内存当中的java对象成为垃圾数据的时候，会被垃圾回收器回收。
- 什么时候堆内存中的java对象会变成垃圾呢？
  - 没有更多的引用指向它的时候，这个对象无法被访问。因为访问对象只能通过引用的方式访问。
## 空指针异常
<pre>
public class OOTest05{
  public static void main(String[] args){

    Customer c = new Customer();
    System.out.println(c.id); //0

    c = null;

    //以下程序编译可以通过，因为符合语法
    //运行出现空指针异常。
    //空引用访问“实例”相关的数据一定会出现空指针异常
    //java.lang.NullPointerException
    System.out.println(c.id);

    //“实例”相关的数据表示：这个数据访问的时候必须有对象的参与。这种数据就是实例相关的数据。
  }
</pre>
## 面向对象包括三大特征：封装、继承、多态
1. 封装的好处
   - 封装之后，对于那个事物来说，看不到这个事物比较复杂的那一面，只能看到该事物简单的那一面。复杂性封装，对外提供简单的操作入口。照相机就是一个很好的封装的案例，照相机的实现原理非常复杂，但是对于使用照相机的人来说，操作起来是非常方便的是非常便捷的。还有像电视机也是封装的，电视机内部实现非常复杂，但是对于使用者来说不需要关心内部的实现原理，只需要会操作遥控器就行。
   - 封装之后才会形成真正的“对象”，真正的“独立体”
   - 封装就意味着以后的程序可以重复使用。并且这个事物应该适应性比较强，在任何场合都可以使用。
   - 封装之后，对于事物本身，提高了安全性。[安全级别高]
2. 封装的步骤：
   - 所有属性私有化，使用private关键字进行修饰，private表示私有的，修饰的所有数据只能在本类中访问。
   - 对外提供简单的操作入口，也就是说以后外部程序要想访问age属性，必须通过这些简单的入口进行访问：
     - 对外提供两个公开的方法，分别是set方法和get方法
     - 想修改age属性，调用set方法
     - 想读取age属性，调用get方法
   - set方法的命名规范：
     - public void set + 属性名首字母大写(形参){}
     - 比如：
<pre>
public void setAge(int a){
  age = a;
}
</pre>
   - get方法的命名规范：
     - public 返回值类型 get + 属性名首字母大写(形参){}
<pre>
public void getAge(){
  return age;
}
</pre>
   - 回想一下，一个属性通常访问的时候包括几种访问形式？
     - 第一种方式：想读取这个属性的值，读取get
     - 第二种方式：想修改这个属性的值，修改set
   - setter and getter方法没有static关键字
   - 有static关键字修饰的方法怎么调用：类名.方法名(实参);
   - 没有static关键字修饰的方法怎么调用：引用.方法名(实参);
## 构造方法
1. 构造方法又被称为构造函数/构造器/Constructor
2. 构造方法语法结构：
<pre>
[修饰符列表] 构造方法名(形式参数列表){
  方法体;        
}
</pre>
3. 回顾普通方法的语法结构
<pre>
[修饰符列表] 返回值类型 方法名(形式参数列表){
  方法体;
}
</pre>
4. 对于构造方法来说，“返回值类型”不需要指定，并且也不能写void，只要写上void，那么这个方法就成为普通方法了。
5. 对于构造方法来说，构造方法的方法名必须和类名保持一致。
6. 构造方法的作用？
- 构造方法存在的意义是，通过构造方法的调用，可以创建对象。
7. 构造方法应该怎么调用？
- 普通方法是这样调用的：
  - 方法修饰符中有static的时候：类名.方法名(实参列表)
  - 方法修饰符中没有static的时候：引用.方法名(实参列表)
- new 构造方法名(实参列表)
8. 构造方法调用执行之后，有返回值吗？
- 每一个构造方法实际上执行结束之后都有返回值，但是这个“return 值;”这样的语句不需要写。构造方法结束的时候java程序自动返回值，并且返回值类型是构造方法所在类的类型。由于构造方法的返回值类型就是类本身，所以返回值类型不需要编写。
**注释和取消注释：ctrl + /，多行注释：ctrl + shift + /**
9.  当一个类中没有定义任何构造方法的话，系统默认给该类提供一个无参数的构造方法，这个构造方法被称为缺省构造器。
10.  当一个类显示的将构造方法定义出来了，那么系统则不再默认为这个类提供缺省构造器。建议开发中手动的为当前类提供无参数构造方法。因为无参数构造方法太常用了。
11.  构造方法支持重载机制。在一个类当中编写多个构造方法，这多个构造方法显然已经构成方法重载机制。
12.  只要构造函数调用就会创建对象，并且一定是在“堆内存”中开辟内存空间。
**怎么查看访问的是哪个属性，查看访问的是哪个方法：按住ctrl，鼠标移动到查看的元素上，出现下划线的时候开始单击。**
13. 构造方法不仅可以创建对象，还能给实例变量赋值
- 成员变量之实例变量，属于对象级别的变量，这种变量必须先有对象才能有实例变量。实例变量没有手动赋值的时候，系统默认赋值，那么这个系统默认赋值是在什么时候完成的呢？
  - 是在类加载的时候吗？
    - 不是，因为类加载的时候只加载了代码片段，还没来得及创建对象。所以此时实例变量并没有初始化。
  - 实际上，实例变量的内存空间是在构造方法执行过程当中开辟的。完成初始化的。系统在默认赋值的时候，也是在构造方法执行过程当中完成的赋值。
## 对象和引用
- 对象和引用的概念
  - 对象：目前在使用new运算符在堆内存中开辟的内存空间称为对象。
  - 引用：是一个变量，不一定是局部变量，还可能是成员变量。引用保存了内存地址，指向了堆内存当中的对象。
  - 所有访问实例相关的数据，都需要通过“引用.”的方式访问，因为只有通过引用才能找到对象。
  - 只有一个空的引用，访问对象的实例相关的数据会出现空指针异常。
<pre>  
class Student{
  Computer com; //com是一个引用[实例变量]

  public static void doSome(){
    Computer cc；//cc是一个引用[局部变量]
  }
}
</pre>
- 参数的传递
  - 参数传递实际上传递的是变量中保存的具体值
  - 方法调用的时候，涉及到参数传递的问题，传递的时候，java只遵循一种语法机制，就是将变量中保存的“值”传递过去了，只不过有的时候这个值是一个字面值10，有的时候这个值是另一个java对象的内存地址0x1234
<pre>
int i = 10;
add(i);等同于add(10);
</pre>
<pre>
User u = new User(20);
//User u = 0x1234;
//传递u给add方法的时候，实际上传递的是u变量中保存的值，只不过这个值是一个java对象的内存地址。
add(u);//等同于add(0x1234);
</pre>
## this关键字
1. this是一个关键字，翻译为：这个
2. this是一个引用，this是一个变量，this变量中保存了内存地址指向了自身，this存储在JVM堆内存java对象内部。
3. 创建100个java对象，每一个对象都有this，也就说有100个不同的this
4. this可以出现在“实例方法”当中，this指向当前正在执行这个动作的对象(this代表当前对象)
5. this在多数情况下都是可以省略不写的
6. this不能使用在带有static的方法中
7. 在带有static的方法当中不能“直接”访问实例变量和实例方法。因为实例变量和实例方法都需要对象的存在。而static的方法当中是没有this的。也就是说当前对象是不存在的。自然也是无法访问当前对象的实例变量和实例方法。
- 没有static关键字的方法被称为“实例方法”，实例方法怎么访问？“引用”
- 没有static关键字的方法被称为“实例变量”
**当一个行为/作动执行的过程当中是需要对象参与的，那么这个方法一定要定义为“实例方法”，不要带static关键字**
**this.什么时候不能省略：用来区分局部变量和实例变量的时候，this.不能省略**
- this可以用在哪里：
  - 可以使用在实例方法当中，代表当前对象[语法格式：this.]
  - 可以使用在构造方法当中，通过当前的构造方法调用其他的构造方法[语法格式：this(实参);]
**this()这种语法只能出现在构造函数第一行。**
- 带有static的方法，其实既可以采用类名的方式访问，也可以采用引用的方式访问，但是即使采用引用的方式去访问，实际上执行的时候和引用指向的对象无关，所以带有static的方法还是建议使用“类名.”的方式访问。
## 例题
<pre>
public class Test(){

  //没有static的变量
  int i = 10;

  //带有static的方法
  public static void doSome(){
    System.out.println("do some!");
  }

  //没有static的方法
  public void doOther(){
    System.out.println("do other!");
  }

  //带有static的方法
  public static void method1(){

    //调用doSome
    //完整方式的调用
    Test.doSome();
    //省略方式的调用
    doSome();

    //调用doOther
    //完整方式的调用
    Test tt = new test();
    tt.doOther();
    //省略方式的调用
    无

    //访问i
    //完整方式的调用
    System.out.println(tt.i);
    //省略方式的调用
    无

  }
    //没有static的方法
    public void method2(){

      //调用doSome
      完整方式的调用
      Test.doSome();
      省略方式的调用
      doSome();

      //调用doOther
      //完整方式的调用
      this.doOther();
      //省略方式的调用
      doOther();

      //访问i
      //完整方式的调用
      System.out.println(this.i);
      //省略方式的调用
      System.out.println(i);
    }
    //主方法
    public static void main(String[] args){

      //要求在这里编写程序调用method1
      //使用完整方式调用
      Test.method1();
      //使用省略方式调用
      method1();

      //要求在这里编写程序调用method2
      //使用完整方式调用
      Test t = new Test();
      t.method2();
      //使用省略方式调用
      无

    }
}
</pre>
## static关键字
1. static英语单词翻译为静态的
2. static修饰的方法是静态方法
3. static修饰的变量是静态变量，静态变量在类加载的时候初始化，不需要创建对象，内存就开辟了。静态变量存储在方法区内存当中。
4. 所有static修饰的元素都称为静态的，都可以使用“类名.”的方式访问，当然也可以用“引用.”的方式访问[但不建议]
5. static修饰的所有元素都是类级别的特征，和具体的对象无关。
- 什么时候成员变量声明为实例变量呢？
  - 所有对象都有这个属性，但是这个属性的值会随着对象的变化而变化[不同对象的这个属性具体的值不同]
- 什么时候成员变量声明为静态变量呢？
  - 所有对象都有这个属性，并且所有对象的这个属性的值是一样的，建议定义为静态变量，节省内存的空间。
1. 可以使用static关键字来定义“静态代码块”。
<pre>
语法格式：
  static{
    java语句;
  }
</pre>
2. 静态代码在类加载时执行，并且只执行一次。
3. 静态代码在一个类中可以编写多个，并且遵循自上而下的顺序依次执行。
4. 静态代码块的作用是什么？怎么用？用在哪儿？什么时候用？
- 和具体的需求有关，例如项目中要求在类加载的时刻/时机执行代码完成日志的记录。那么这段记录日志的代码就可以编写到静态代码当中，完成日志记录。
- 静态代码块是java为程序员准备的一个特殊时刻，这个特殊的时刻被称为类加载时刻。若希望在此刻执行一段特殊的程序，这段程序可以直接放到静态代码块当中。
5. 通常在静态代码块当中完成预备工作，先完成数据的准备工具，例如：初始化连接池，解析XML配置文件
## 实例语句块/代码块[了解内容，使用的非常少]
1. 实例代码块可以编写多个，也是遵循自上而下的顺序依次执行
2. 实例代码块在构造方法执行之前执行，构造方法执行一次，实例代码块对应执行一次。
3. 实例代码块也是java语言为程序员准备一个特殊的时机，这个特殊时机被称为：对象初始化时机。
## 静态方法
- 方法什么时候定义为静态的？
  - 方法描述的是动作，当所有的对象执行这个动作的时候，最终产生影响是一样的，那么这个动作已经不再属于某一个对象动作了，可以将这个动作提升为类级别的动作，模板级别的动作。
- 静态方法中无法直接访问实例变量和实例方法
- 大多数方法都定义为实例方法，一般一个行为或者一个动作在发生的时候，都需要对象的参与。但是也有例外，例如：大多数“工具类”中的方法都是静态方法，因为工具类就是方便编程，为了方便方法的调用，自然不需要new对象是最好的。
<pre>
class 类{
  静态代码块;
  实例代码块;

  静态变量
  实例变量

  构造方法

  静态方法
  实例方法
}
</pre>
## 继承
1. 继承是面向对象三大特征之一，三大特征分别是：封装、继承、多态
2. 继承“基本”的作用是：代码复用。但是继承最“重要”的作用是：有了继承才有了以后“方法的覆盖”和“多态机制”。
3. 继承语法格式：
[修饰符列表] class 类名 extends 父类名{
  类体 = 属性 + 方法
}
4. java语言当中的继承只支持单继承，一个类不能同时继承很多类，只能继承一个类。在C++中支持多继承。
5. 关于继承中的一些术语：
  B类继承A类，其中：
    A类称为：父类、基类、超类、superclass
    B类称为：子类、派生类、subclass
6. 在java语言当中子类继承父类都继承哪些数据呢？
- 私有的不支持继承
- 构造方法不支持继承
- 其他数据都可以被继承
7. 虽然java语言当中只支持单继承，但是一个类也可以间接继承其他类，例如：
  C extends B{
  }
  B extends A{
  }
  A extends T{    
  }
  C直接继承B类，但是C类间接继承T、A类。
8. java语言中假设一个类没有显示的继承任何类，该类默认继承javaSE库当中提供的java.lang.Object类。java语言中任何一个类中都有Object类的特征。